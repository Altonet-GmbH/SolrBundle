
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SolrBundle</title>
    
    <meta name="author" content="Florian Semm">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="http://floriansemm.github.io/SolrBundle/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="http://floriansemm.github.io/SolrBundle/assets/themes/twitter/css/style.css" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->


  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <a class="brand" href="http://github.com/floriansemm/SolrBundle">Documentation for SolrBundle</a>
          <ul class="nav">
            
            
            


  
    
      
    
  
    
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container-narrow">

      <div class="content">
        
<div class="page-header">
  <h1>SolrBundle  <small>symfony2 doctrine2 solr</small></h1>
</div>

<div class="row-fluid">
  <div class="span12">
    <p><a href="http://travis-ci.org/floriansemm/SolrBundle"><img alt="Build Status" src="https://secure.travis-ci.org/floriansemm/SolrBundle.png?branch=master" /></a> <a href="http://waffle.io/floriansemm/solrbundle"><img alt="Stories in Ready" src="http://badge.waffle.io/floriansemm/solrbundle.png" /></a></p>

<p>This Bundle provides a simple API to index and query a Solr Index.</p>

<h1 id="configuration">Configuration</h1>

<p>The bundle requires a working doctrine-orm or doctrine-mongodb configuration. There are no differences in the use.</p>

<h2 id="install_the_bundle">Install the Bundle</h2>

<p>Bundle</p>

<ol>
<li>
<p>Register bundle in AppKernel.php</p>

<pre><code># app/AppKernel.php

$bundles = array(
    // ...
    new FS\SolrBundle\FSSolrBundle(),
    // ...
);</code></pre>
</li>

<li>
<p>Add Bundle to autoload</p>

<p>A. Via composer, add in your composer.json</p>

<pre><code>&quot;require&quot;: {
    // ...  
    &quot;floriansemm/solr-bundle&quot;: &quot;dev-master&quot;
}</code></pre>

<p>B. or manually, in app/autoload.php</p>

<p>i. In symfony 2.1.4 (supposing you clone the bundle in vendor/floriansemm/solr-bundle/FS/, making available vendor/floriansemm/solr-bundle/FS/SolrBundle/FSSolrBundle.php)</p>

<pre><code>$loader-&gt;add('FS\\SolrBundle', array(__DIR__.'/../vendor/floriansemm/solr-bundle'));		</code></pre>

<p>ii. in older version it could be</p>

<pre><code>$loader-&gt;registerNamespaces(array(
    // ...
    'FS' =&gt; __DIR__.'/../vendor/bundles',
    // ...
));</code></pre>
</li>
</ol>

<h2 id="multiple_indexes">Multiple Indexes</h2>

<p>You have to setup the connection options</p>

<pre><code># app/config/config.yml
fs_solr:
  endpoints:
    default:
      host: host
      port: 8983
      path: /solr/
      core: corename
      timeout: 5
  clients:
    default:
      endpoints: [default]</code></pre>

<p>With this config you have access to the service <code>solr.client.default</code>. If you have more client you can access them with the call <code>solr.client.clientname</code></p>

<h1 id="usage">Usage</h1>

<h2 id="annotations">Annotations</h2>

<p>To put an entity to the index, you must add some annotations to your entity:</p>

<pre><code>// your Entity

// ....
use FS\SolrBundle\Doctrine\Annotation as Solr;

/**
 * @Solr\Document(repository=&quot;Full\Qualified\Class\Name&quot;)
 * @ORM\Table()
 */
class Post
{
	/**
	 * @Solr\Id
	 *
	 * @ORM\Column(name=&quot;id&quot;, type=&quot;integer&quot;)
	 * @ORM\Id
	 * @ORM\GeneratedValue(strategy=&quot;AUTO&quot;)
	 */

	private $id;
	/**
	 *
	 * @Solr\Field(type=&quot;string&quot;)
	 *
	 * @ORM\Column(name=&quot;title&quot;, type=&quot;string&quot;, length=255)
	 */
	private $title = '';

	/**
	* 
	* @Solr\Field(type=&quot;string&quot;)
	*
	* @ORM\Column(name=&quot;text&quot;, type=&quot;text&quot;)
	*/
	private $text = '';

	/**
	* @Solr\Field(type=&quot;date&quot;)
	*
	* @ORM\Column(name=&quot;created_at&quot;, type=&quot;datetime&quot;)
	*/
	private $created_at = null;
}</code></pre>

<h3 id="supported_field_types">Supported field types</h3>

<p>Currently is a basic set of types implemented.</p>

<ul>
<li>string</li>

<li>text</li>

<li>date</li>

<li>integer</li>

<li>float</li>

<li>double</li>

<li>long</li>

<li>boolean</li>
</ul>

<p>It is possible to use custum field types (schema.xml).</p>

<h3 id="filter_annotation">Filter annotation</h3>

<p>In some cases a entity should not be index. For this you have the <code>SynchronizationFilter</code> Annotation.</p>

<pre><code>/**
* @Solr\Document
* @Solr\SynchronizationFilter(callback=&quot;shouldBeIndex&quot;)
*/
class SomeEntity
{
	/**
	* @return boolean
	*/
	public function shouldBeIndex()
	{
		// put your logic here
	}
}</code></pre>

<p>The callback property specifies an callable function, which decides whether the should index or not.</p>

<h2 id="solr_field_configuration">Solr field configuration</h2>

<p>Solr comes with a set of predefined field-name/field-types mapping:</p>

<ul>
<li>title (solr-type: general_text)</li>

<li>text (solr-type: general_text)</li>

<li>category (solr-type: general_text)</li>

<li>content_type (solr-type: string)</li>
</ul>

<p>For details have a look into your schema.xml.</p>

<p>So if you have an entity with a property “category”, then you don’t need a type-declaration in the annotation:</p>

<pre><code>/**
* @Solr\Field
* @ORM\Column(name=&quot;category&quot;, type=&quot;text&quot;)
*/
private $category = '';</code></pre>

<p>The field has in this case automaticaly the type “general_text”.</p>

<p>If you persist this entity, it will put automaticlly to the index. Update and delete happens automatically too.</p>

<h2 id="query_a_field_of_a_document">Query a field of a document</h2>

<p>To query the index you have to call some services.</p>

<pre><code>$query = $this-&gt;get('solr')-&gt;createQuery('AcmeDemoBundle:Post');
$query-&gt;addSearchTerm('title', 'my title');

$result = $result = $query-&gt;getResult();</code></pre>

<p>The $result array contains all found entities. The solr-service does all mappings from SolrDocument to your entity for you.</p>

<h2 id="query_all_fields_of_a_document">Query all fields of a document</h2>

<p>The pervious examples have queried only the field ‘title’. You can also query all fields with a string.</p>

<pre><code>$query = $this-&gt;get('solr')-&gt;createQuery('AcmeDemoBundle:Post');
$query-&gt;queryAllFields('my title');

$result = $query-&gt;getResult();</code></pre>

<h2 id="define_resultmapping">Define Result-Mapping</h2>

<p>To narrow the mapping, you can use the <code>addField()</code> method.</p>

<pre><code>$query = $this-&gt;get('solr')-&gt;createQuery('AcmeDemoBundle:Post');
$query-&gt;addSearchTerm('title', 'my title');
$query-&gt;addField('id');
$query-&gt;addField('text');

$result = $query-&gt;getResult();</code></pre>

<p>In this case only the fields id and text will be mapped (addField()), so title and created_at will be empty. If nothing was found $result is empty.</p>

<h2 id="configure_hydrationmodes">Configure HydrationModes</h2>

<p>HydrationMode tells the Bundle how to create an entity from a document.</p>

<ol>
<li><code>FS\SolrBundle\Doctrine\Hydration\HydrationModes::HYDRATE_INDEX</code> - use only the data from solr</li>

<li><code>FS\SolrBundle\Doctrine\Hydration\HydrationModes::HYDRATE_DOCTRINE</code> - merge the data from solr with the entire doctrine-entity</li>
</ol>

<p>With a custom query:</p>

<pre><code>$query = $this-&gt;get('solr')-&gt;createQuery('AcmeDemoBundle:Post');
$query-&gt;setHydrationMode($mode)</code></pre>

<p>With a custom document-repository you have to set the property <code>$hydrationMode</code> itself:</p>

<pre><code>public function find($id)
{
    $this-&gt;hydrationMode = HydrationModes::HYDRATE_INDEX;

    return parent::find($id);
}</code></pre>

<h2 id="index_manually_an_entity">Index manually an entity</h2>

<p>To index your entities manually, you can do it the following way:</p>

<pre><code>$this-&gt;get('solr')-&gt;addDocument($entity);
$this-&gt;get('solr')-&gt;updateDocument($entity);
$this-&gt;get('solr')-&gt;deleteDocument($entity);</code></pre>

<p><code>deleteDocument()</code> requires that the entity-id is set.</p>

<h2 id="use_document_repositories">Use document repositories</h2>

<p>If you specify your own repository you must extend the <code>FS\SolrBundle\Repository\Repository</code> class. The useage is the same like Doctrine-Repositories:</p>

<pre><code>$myRepository = $this-&gt;get('solr')-&gt;getRepository('AcmeDemoBundle:Post');
$result = $myRepository-&gt;mySpecialFindMethod();</code></pre>

<p>If you haven’t declared a concrete repository in your entity and you calling <code>$this-&gt;get('solr')-&gt;getRepository('AcmeDemoBundle:Post')</code>, you will get an instance of <code>FS\SolrBundle\Repository\Repository</code>.</p>

<h2 id="commands">Commands</h2>

<p>There are comming two commands with this bundle:</p>

<ul>
<li><code>solr:index:clear</code> - delete all documents in the index</li>

<li><code>solr:synchronize</code> - synchronize the db with the index</li>
</ul>
  </div>
</div>


      </div>
      <hr>
      <footer>
        <p>&copy; 2014 Florian Semm
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div>

    
  </body>
</html>

